package service.aiimport service.RootServiceimport entity.GameStateclass AIService (private val rootService:RootService,                 val simulationCount: Int = 1000, aiIndex: Int )   {    private val helpFunctions = HelpFunctions(rootService)    /**     * Selects the next move for the AI based on the chosen AI strategy.     *     * @param gameState The current state of the game.     */    fun selectNextMove(gameState: GameState) {        val aiPlayer = gameState.players.find { it.isAI }            ?: throw IllegalStateException("Smart AI player not found.")        when (aiPlayer.smartAI) {            false -> {                makeRandomMove()            }            true -> {                // iterations ?                makeSmartMove(gameState, iterations = 10)            }        }    }    /**     * gives a Random move for the AI     * this fun is only for the random AI     *     */    private fun makeRandomMove() {        // Get the current game from the root service        val game = rootService.currentGame        // Check if the current game is valid (i.e., started)        checkNotNull(game) { "No game started yet." }        // need to be able to rotate Tile        while (helpFunctions.hasMovesLeft()) {            val randomPos = helpFunctions.getCurrentValidCoordinates().random()            if (rootService.playerService.checkPlacement(randomPos)){                rootService.playerService.placeTile(randomPos)                break            }        }    }    /**     * Gives a smart move for the AI using Monte Carlo Tree Search (MCTS).     *     * @param currentState The current state of the game.     * @param iterations Number of iterations for the MCTS.     * @return The best move found by the AI.     */    private fun makeSmartMove(currentState: GameState, iterations: Int) {        val rootNode = Node(currentState)        repeat(iterations) {            val expandedNode = expandNode(rootNode)            val simulationResult = simulate(expandedNode, iterations)            backpropagation(expandedNode, simulationResult)        }        // After simulations, choose the best move based on the highest average score        val bestChild = rootNode.children.maxByOrNull { it.totalScore / it.visits.toDouble() }        if (bestChild != null) {            bestChild.action?.let { rootService.playerService.placeTile(it) }        }    }    /**     * Expands the children of the given node by generating all valid states based on the current game state.     *     * @param currentNode The node to expand by creating children nodes.     * @return True if the expansion was successful and children were added, false otherwise.     */    private fun expandNode(currentNode: Node): Node {        // Get the current game from the root service        val game = rootService.currentGame        // Check if the current game is valid (i.e., started)        checkNotNull(game) { "No game started yet." }        // Find all valid positions to make a move from the current state/node        val validPos = rootService.helpFunctions.getCurrentValidCoordinates()        // Create child nodes for all possible states based on the available positions        for (i in 0 until validPos.size) {            // Create a new child node            val currentState = GameState(game.currentBoard, game.currentDrawStack, game.currentPlayers, game.currentGems)            val currentCreatedChild = Node(currentState)            // Set the depth of the child nodes            currentCreatedChild.currentDepth = currentNode.currentDepth + 1            // Set the parent of the new child to the current node            currentCreatedChild.parent = currentNode            // Add the new child to the children of the current parent            currentNode.children.add(currentCreatedChild)            // Take the action "place tile" in the current valid position, updating the game state            //rootService.helpFunctions.playAction(validPos[i])            rootService.playerService.placeTile(validPos[i])            // Assign the taken action to the current child            currentCreatedChild.action = validPos[i]            // Set the new state of the game to the current child            val newGameState = GameState(                game.currentBoard,                game.currentDrawStack,                game.currentPlayers,                game.currentGems            )            currentCreatedChild.currentGameState = newGameState            // Reset the current game state to the previous state (undo the action)            game.currentBoard = currentNode.currentGameState!!.board            game.currentDrawStack = currentNode.currentGameState!!.drawStack            game.currentPlayers = currentNode.currentGameState!!.players            game.currentGems = currentNode.currentGameState!!.gems.toMutableList()        }        // Shuffle the children to introduce randomness        //currentNode.children.shuffle()        // Return the expanded Node        return currentNode    }    /**     * Simulates the game by choosing next states until a terminal state or a specified depth is reached.     *     * @param currentNode The starting node for simulation.     * @param depth The maximum depth to simulate the game up to.     * @return The node representing the simulated state after the simulation process.     */    private fun simulate(currentNode: Node, depth: Int): Boolean {        val game = rootService.currentGame        checkNotNull(game) { "No game started yet." }        while (!helpFunctions.isTerminal(helpFunctions.getCurrentValidCoordinates()) && currentNode.currentDepth <= depth) {            val validPositions = helpFunctions.getCurrentValidCoordinates()            // Check if there are valid positions to move            if (validPositions.isNotEmpty()) {                val randomPos = validPositions.random()                // Simulate the move                rootService.playerService.placeTile(randomPos)                //reward ? #                // itha wsel node final                    // *-1 ken yaghsar                    // + MAX_INT ken yerba7                // itha mech node fina                    // +2 itha gems score goes up for just ki                    // +1 itha gems score goes up for ki and player                    //....            }        }        return false    }    /**     * Applies the backpropagation step after the simulation by updating the scores and visit counts in the tree.     *     * @param currentNode The node representing the state that was chosen for simulation.     * @param aiHaveWon A boolean indicating whether the AI has won in the simulated game.     */    private fun backpropagation(currentNode: Node, aiHaveWon: Boolean) {        // Apply the backpropagation        var currentState = currentNode        // Traverse up the tree from the chosen state's parent to the root        while (currentState.parent != null) {            // Update the total score if AI has won            if (aiHaveWon) {                currentState.totalScore += 1            }            // Increment the visit count for the current node            currentState.visits += 1            // Move to the parent node            currentState = currentState.parent!!        }    }    // place tile maktouba f expand w f simulate??    // f Help functions applyAction zeyda}